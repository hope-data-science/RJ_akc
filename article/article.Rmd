---
title: "akc: A Tidy Framework for Automatic Knowledge Classification in R"
abstract: >
  Knowledge classification is an extensive and effective approach for domain knowledge management. To automatically extract and organize knowledge from unstructured textualized data is desirable and appealing in various circumstances. In this paper, the tidy framework for automatic knowledge classification supported by the \CRANpkg{akc} package is introduced. With the powerful support from the R ecosystem, the \CRANpkg{akc} framework could handle multiple procedures in data science workflow, including text cleaning, keyword extraction, synonyms consolidation and data presentation. While focusing on bibliometric analysis, the \CRANpkg{akc} package is extensible to be used in other contexts. This paper introduces the framework and its features in detail. Specific examples are given to guide the potential users and developers to participate in open science of text mining.
draft: true
author:  
  # see ?rjournal_article for more information
  - name: Tian-Yuan Huang
    affiliation: National Science Library, Chinese Academy of Sciences
    address: Beijing, China
    orcid: 0000-0002-4151-3764
    email:  huangtianyuan@mail.las.ac.cn
  - name: Li Li
    affiliation: National Science Library, Chinese Academy of Sciences
    address:  Beijing, China
    email:  lili2020@mail.las.ac.cn
  - name: Liying Yang
    affiliation: National Science Library, Chinese Academy of Sciences
    address: Beijing, China
    email:  yangly@mail.las.ac.cn 
type: package
output: 
  rjtools::rjournal_web_article
bibliography: article.bib

---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = FALSE, warning = FALSE, message = FALSE)
library(akc)
library(knitr)
```

# Introduction

Co-word analysis has long been used for knowledge discovery, especially in the field of library and information science [@callon1986mapping]. Based on co-occurrence relationships between words or phrases, this method could provide quantitative evidence of information linkages, mapping the association and evolution of knowledge over time. In conjunction with social network analysis (SNA), co-word analysis could be escalated and yield more informative results, such as topic popularity [@huang2019measuring] and knowledge grouping [@khasseh2017intellectual]. Meanwhile, in the area of network science many community detection algorithms have been proposed to unveil the topological structure of the network [@Fortunato-627;@JavedYounis-626]. These methods have then been incorporated into the co-word analysis, assisting to group components in the co-word network. Currently, the co-word analysis based on community detection is flourishing across various fields, including information science, social science and medical science [@hu2013co;@hu2015research;@leung2017bibliometrics;@BaziyadShirazi-628].

For implementation, interactive software applications (e.g. [CiteSpace](http://cluster.cis.drexel.edu/~cchen/citespace/) and [VOSviewer](https://www.vosviewer.com/)) have provided freely available toolkits for automatic co-word analysis, making this technique even more popular. Interactive software applications are generally friendlier to users, but they might not be flexible enough for the whole data science workflow. In addition, the manual adjustments could be variant, bringing extra risks to the research reproducibility. In this paper, we have designed a flexible framework for automatic knowledge classification, and presented an open software package \CRANpkg{akc} supported by R ecosystem for implementation. Based on community detection in co-occurrence network, the package could conduct unsupervised classification on the knowledge represented by extracted keywords. Moreover, the framework would handle tasks such as data cleaning and keyword merging in the upstream of data science workflow, whereas in the downstream it provides both summarized table and visualized figure of knowledge grouping. While the package was first designed for academic knowledge classification in bibliometric analysis, the framework is rather general, so as to benefit a broader audience who are interested in text mining, network science and knowledge discovery. 

# Background

Classification could be identified as a meaningful clustering of experience, turning information into structured knowledge [@kwasnik1999role]. In bibliometric research, this method has been frequently used to group domain knowledge represented by author keywords, usually listed as a part of co-word analysis, keyword analysis or knowledge mapping [@he1999knowledge;@hu2013co;@leung2017bibliometrics;@li2017knowledge;@wang2018three]. While all named as (unsupervised) classification  or clustering, the algorithm behind could vary widely. For instance, some researches have utilized hierarchical clustering to group keywords in into different themes [@hu2015research;@khasseh2017intellectual], whereas the studies applying VOSviewer have adopted a kind of weighted variant of modularity-based clustering with a resolution parameter to identify smaller clusters [@van2010software]. In the framework of \CRANpkg{akc}, we have utilized the modularity-based clustering method known as community detection in network science [@newman2004fast;@Murata2010]. These functions are supported by the \CRANpkg{igraph} package. Main detection algorithms implemented in \CRANpkg{akc} include Edge betweenness [@girvan2002community], Fastgreedy [@Clauset], Infomap [@rosvall2007information;@rosvall2009map], Label propagation [@raghavan2007near], Leading eigenvector [@newman2006finding], Multilevel [@Blondel_2008], Spinglass [@reichardt2006statistical] and Walktrap [@pons2005computing]. The details of these algorithms and their comparisons have been discussed in the previous studies [@de2014evaluating;@yang2016comparative;@garg2017comparative;@8620850].

In practical application, the classification result is susceptible to data variation. The upstream procedures, such as information retrieval, data cleaning and word sense disambiguation, play vital roles in automatic knowledge classification. For bibliometric analysis, the author keyword field provides valuable source of scientific knowledge. These keywords are good representation of domain knowledge and could be used directly for analysis. In addition, such collection of keywords from papers published in specific fields could provide professional dictionary for information retrieval, such as keyword extraction from raw text in the title, abstract and full text of literature. While focuses on automatic knowledge classification based on community detection in keyword co-occurrence network, the \CRANpkg{akc} framework also provides utilities for keyword-based knowledge retrieval, text cleaning, synonyms merging and data visualization in data science workflow. These tasks might have different requirements in specific backgrounds. Currently, \CRANpkg{akc} concentrates on keyword-based bibliometric analysis of scientific literature. Nonetheless, the R ecosystem is versatile, and the popular tidy data framework is flexible to extend to various data science tasks from other different fields [@wickham2014tidy;@wickham2016r], which benefits both end-users and software developers.  In addition, when users have more specific needs in their tasks, they could easily seek other powerful facilities from R community. For instance, \CRANpkg{akc} provides functions to extract keywords using n-grams model (utilizing facilities provided by \CRANpkg{tidytext}), but skip-gram modelling is not supported currently. This functionality, on the other hand, could be provided in \CRANpkg{tokenizers} or \CRANpkg{quanteda} package in R. A greater picture of natural language processing (NLP) in R could be found in the [CRAN Task View: Natural Language Processing](https://cran.r-project.org/web/views/NaturalLanguageProcessing.html). 

# Framework

An overview of the framework is given in Figure \@ref(fig:fig1). Note that the name \CRANpkg{akc} refers to the overall framework for automatic keyword classification as well as the released R package in this paper. The whole workflow could be largely divided into four procedures: (1) Keyword extraction (optional); (2) Keyword preprocessing; (3) Network construction and clustering; (4) Results presentation.

```{r fig1, out.width = "100%", out.height = "30%", fig.cap = "The design of akc framework."}
knitr::include_graphics("fig1.png")
```

(1)	Keyword extraction (optional)

In bibliometric meta-data entries, the textual information of title, abstract and keyword are usually provided for each paper. If the keywords were used directly, there is no need to do information retrieval. Then we could directly skip this procedure and start from keyword preprocessing. However, sometimes the keyword field is missing, then we would need to extract the keywords from raw text in the title, abstract or full text with an external dictionary. At other times, one might want to get more keywords and their co-occurrence relationships from each entry. In such case, the keyword field could serve as an internal dictionary for information retrieval in the provided raw text.

Figure \@ref(fig:fig2) has displayed an example of keyword extraction procedure. First, the raw text would be split into sub-sentences (clauses), this could suppress the generation of cross-clause n-grams. Then the sub-sentences would be tokenized into n-grams. The `n` could be specified by the users, inspecting the average number of words in keyword phrases might help decide the maximum number of `n`. Finally, a filter is made. Only tokens that have emerged in the user-defined dictionary are retained for further analysis. The whole keyword extraction procedure could be implemented automatically with `keyword_extract` function in \CRANpkg{akc}.

```{r fig2, out.width = "100%", out.height = "30%", fig.cap = "An example of keyword extraction procedure (the letters are automatically turned to lower case in sentence division)."}
knitr::include_graphics("fig2.png")
```

(2) Keyword preprocessing

In practice, the textualized contents are seldom clean enough to implement analysis directly. Therefore, the upstream data cleaning process is inevitable. In keyword preprocessing procedure of \CRANpkg{akc} framework, the cleaning part would take care of some details in the preprocess, such as convert the letters to lower case and remove parentheses and contents inside (optional). For merging part, \CRANpkg{akc} help merge the synonymous phrases according to their lemmas or stems. While using lemmatization and stem extracting would get abnormal knowledge tokens, here in \CRANpkg{akc} we have designed a conversion rule to tackle this problem. We first get the lemmatized or stemmed form of keywords, then group the keywords by their lemma or stem, and let the most frequent keyword in the group to represent the original keyword. This step could be realized by `keyword_merge` function in \CRANpkg{akc} package. An example could be found in Figure \@ref(fig:fig3). After keyword merging, there might still be too many keywords included in the analysis, which poses great burden for computation in the subsequent procedures. Therefore, a filter should be carried out here, it could exclude the infrequent terms, or extract top TF-IDF terms, or use any criteria that meets the need. Last, a manual validation should be carried out to ensure the final data quality. 

```{r fig3, out.width = "100%", out.height = "25%", fig.cap = "An example of keyword merging conversion rule applied in akc. The keywords with the same lemma (or stem) would be merged to the highest frequency keyword in the original form."}
knitr::include_graphics("fig3.png")
```

(3)	Network construction and clustering

Based on keyword co-occurrence relationship, the keyword pairs would form an edge list and be used to construct an undirected network. Then the facilities provided by \CRANpkg{igraph} package would automatically group the nodes (representing the keywords). This procedure could be achieved by using `keyword_group` function in \CRANpkg{akc}.

(4)	Results presentation

Currently, there are two kinds of output presented by \CRANpkg{akc}. One is a summarized result, namely a table with group number and keyword collections (attached with frequency). Another is network visualization, which has two modes. The local mode provides a keyword co-occurrence network by group (use facets in \CRANpkg{ggplot2}), whereas the global mode displays the whole network structure. Note that one might include huge number of keywords and make a huge network, but in presentation the users could choose how many keywords from each group to be displayed. More details could be found in the following sections.


The \CRANpkg{akc} framework could never be built without the powerful support provided by R community. The \CRANpkg{akc} package was developed under R environment, and main packages imported to \CRANpkg{akc} framework include \CRANpkg{data.table} (for high performance computing), \CRANpkg{dplyr} (for tidy data manipulation), \CRANpkg{ggplot2} (for data visualization), \CRANpkg{ggraph} (for network visualization), \CRANpkg{ggwordcloud} (for word cloud visualization), \CRANpkg{igraph} (for network analysis), \CRANpkg{stringr} (for string operations), \CRANpkg{textstem} (for lemmatizing and stemming), \CRANpkg{tidygraph} (for network data manipulation) and \CRANpkg{tidytext} (for tidy tokenization). Getting more understandings on these R packages could help users utilize more alternative functions, so as to complete more specific and complex tasks. Hopefully, the users might also become potential developers of the \CRANpkg{akc} framework in the future. 

# Example

This section shows how \CRANpkg{akc} can be used in a real case. A collection of bibliometric data of *R Journal* from 2009 to 2021 is used in this example. The data of this example can be accessed in the [GitHub repository](https://github.com/hope-data-science/RJ_akc). Only \CRANpkg{akc} package would be used in this workflow, first we would load the package and import the data in the R environment.

```{r, echo=TRUE}
library(akc)
rj_bib = readRDS("./rj_bib.rds")
rj_bib
```

`rj_bib` is a data frame with 4 columns, including *id* (Paper ID), *title* (Title of paper), *abstract* (Abstract of paper) and *year* (Publcation year of paper). Papers in *R Journal* do not contain keyword field, thus we would have to extract the keywords from the title or abstract field (first step in Figure \@ref(fig:fig1)). Here in our case, we would use abstract field as our data source. In addition, we would need a user-defined dictionary to extract the keywords, otherwise all the n-grams (meaningful or meaningless) would be extracted and the results would include redundant noise.

```{r, echo=TRUE}
# import the user-defined dictionary
rj_user_dict = readRDS("./rj_user_dict.rds")
rj_user_dict
```

Note that the dictionary should be a data.frame with only one column named "keyword". The user can also use `make_dict` function to build the dictionary data.frame with a string vector. This function removes duplicated phrases, turn them to lower case and sort them, which potentially improving the efficiency for the following processes.

```{r,echo=TRUE}
rj_dict = make_dict(rj_user_dict$keyword)
```

With the bibliometric data (`rj_bib`) and dictionary data (`rj_dict`), we could start the workflow provided in Figure \@ref(fig:fig1).

(1) Keyword extraction

In this step, we need a bibliometric data table with simply two informative columns, namely paper ID (*id*) and the raw text field (in our case *abstract*). The parameter *dict* is also specified to extract only keywords emerging in the user-defined dictionary. The implementation is very simple.

```{r,echo=TRUE}
rj_extract_keywords = rj_bib %>% 
  keyword_extract(id = "id",text = "abstract",dict = rj_dict)
```

By default, only phrases range 1 to 4 in length are included as extracted keywords. The user can update this range using parameters `n_min` and `n_max` in `keyword_extract` function. These is also a `stopword` parameter, allowing users to exclude specific keywords in the extracted phrases. The output of `keyword_extract` is a pretty displayed data.frame (tibble,`tbl_df` class provided by \CRANpkg{tibble} package) with two columns, namely paper ID (*id*) and the extracted keyword (*keyword*).

(2) Keyword preprocessing

For the preprocessing part, `keyword_clean` and `keyword_merge` would be implemented. In the cleaning part, the `keyword_clean` function would: 1) Split the text with separators (If no separators exist, skip); 2) Remove the contents in the parentheses (including the parentheses, optional); 3) Remove white spaces from start and end of string and reduces repeated white spaces inside a string; 4) Remove all the null character string and pure number sequences (optional); 5) Convert all letters to lower case; 6) Lemmatization (optional). The merging part has been illustrated in the previous section, thus would not be explained again. In the tidy workflow, the preprocessing could be implemented via:

```{r,echo=TRUE}
rj_cleaned_keywords = rj_extract_keywords %>% 
  keyword_clean() %>% 
  keyword_merge()
```

No parameters are used in these functions because \CRANpkg{akc} has been designed to input and output tibbles with consistent column names. If the users have data tables with different column names, specify them in arguments (`id` and `keyword`) provided by the functions. More details could be found in the help document (use `?keyword_clean` and `?keyword_merge` in the console).

(3)	Network construction and clustering

To construct a keyword co-occurrence network, only a data table with two columns (with paper ID and keyword) is needed. All the details have been taken care of in the `keyword_group` function. However, the user could specify: 1) the community detection function (use `com_detect_fun` argument); 2) the filter rule of keywords according to frequency (use `top` or `min_freq` argument, or both). In our example, we would use the default settings (utilizing Fastgreedy algorithm, only top 200 keywords by frequency would be included).

```{r,echo=TRUE}
rj_network = rj_cleaned_keywords %>% 
  keyword_group()
```

The output object `rj_network` is a `tbl_graph` class supported by \CRANpkg{tidygraph}, this is a tidy data format containing the network data. Based on this data, we can present the results in various forms in the next section.

(4) Results presentation

Currently, there are two major ways to display the classified results in \CRANpkg{akc}, namely network and table. A fast way to gain the network visualization is using `keyword_vis` function:

```{r fig4,echo=TRUE,fig.cap="Network visualization provided by akc.",fig.align='center'}
rj_network %>% 
  keyword_vis()
```
In Figure \@ref(fig:fig4), the keyword co-occurrence network is clustered into three groups. The size of nodes is proportional to the keyword frequency, while the transparency degree of edges is proportional to the co-occurrence relationship between keywords. For each group, only top 10 keywords by frequency are showed in each facet. If the user wants to dig into Group 1, `keyword_network` could be applied. Also, `max_nodes` parameter could be used to control how many nodes to be showed (in our case, we show 20 nodes in the visualization displayed in Figure \@ref(fig:fig5)).  

```{r fig5,echo=TRUE,fig.cap="Focus on one cluster (Group 1) of the network. Top 20 keywords by frequency are showed.",fig.align='center'}
rj_network %>% 
  keyword_network(group_no = 1,max_nodes = 20) 
```   

Another displayed form is using table. This could be implemented by `keyword_table` via:

```{r table1,echo=TRUE}
rj_table = rj_network %>% 
  keyword_table() 
```

This would return a data.frame with two columns (see Table `r knitr::asis_output(ifelse(knitr::is_html_output(), '\\@ref(tab:tab1-1)', '\\@ref(tab:tab1-2)'))`), one is the group number, the other is the keywords (by default, only top 10 keywords by frequency would be displayed, and the frequency information is attached). 

```{r tab1-1, eval = knitr::is_html_output(), layout = "l-body-outset"}
knitr::kable(rj_table, format = "html", caption = "Informative table exported by akc.",align = "c")%>% 
  kableExtra::kable_styling(position = "center") %>% 
  kableExtra::column_spec(2, width = "16cm")
```

```{r tab1-2, eval = knitr::is_latex_output()}
knitr::kable(rj_table, format = "latex", caption = "Informative table exported by akc.",align = "c") %>% 
  kableExtra::kable_styling(font_size = 7) %>%
  kableExtra::column_spec(2, width = "10cm")
```   

Word cloud visualization is also supported by \CRANpkg{akc} via \CRANpkg{ggwordcloud} package, this could be implemented by using `keyword_cloud` function.

# Discussion

The core functionality of the akc framework is to automatically group the knowledge pieces (keywords) using modularity-based clustering. Because this process is unsupervised, it could be difficult to evaluate the outcome of classification. Nevertheless, the default setting of community detection algorithm was selected after empirical tests via [benchmarking](https://cran.r-project.org/web/packages/akc/vignettes/Benchmarking.html). It was found that: 1) Edge betweenness and Spinglass algorithm are most time-consuming; 2) Edge betweenness and Walktrap algorithm could potentially find more local clusters in the network; 3) Label propagation could hardly divide the keywords into groups; 4) Infomap has high standard deviation of node number across groups. In the end, Fastgreedy was chosen as the default community detection algorithm in \CRANpkg{akc}, because its performance is relatively stable, and the number of groups increases proportionally with the network size.

Though \CRANpkg{akc} currently focuses on automatic knowledge classification based on community detection in keyword co-occurrence network, this framework is rather general in many natural language processing problems. One could utilize part of the framework to complete some specific tasks, such as word consolidating (using keyword merging) and n-gram tokenizing (using keyword extraction with a null dictionary), then export the tidy table and work in another environment. As long as the data follows the rule of tidy data format [@wickham2014tidy], the \CRANpkg{akc} framework could be easily decomposed and applied in various circumstances. For instance, by considering the nationalities of authors as keywords, \CRANpkg{akc} framework could also investigate the international collaboration behavior in the specific domain. 

In the meantime, the \CRANpkg{akc} framework is still in active development, trying new algorithms to carry out better unsupervised knowledge classification under the R environment. The expected new directions include more community detection functions, new clustering methods, better visualization settings, etc. Note that except for the topology-based community detection approach considering graph structure of the network, there is still another topic-based approach considering the textual information of the network nodes [@Ding-629], such as hierarchical clustering [@Newman-633], latent semantic analysis [@LandauerFoltz-635] and Latent Dirichlet Allocation [@BleiNg-634]. These methods are also accessible in R, the relevant packages could be found in the [CRAN Task View: Natural Language Processing](https://cran.r-project.org/web/views/NaturalLanguageProcessing.html). With the tidy framework, \CRANpkg{akc} could assimilate more nutrition from the modern R ecosystem, and move forward to create better reproducible open science schemes in the future.

# Conclusion

In this paper, we have proposed a tidy framework of automatic knowledge classification supported by a collection of R packages integrated by \CRANpkg{akc}. While focusing on data mining based on keyword co-occurrence network, the framework also supports other procedures in data science workflow, such as text cleaning, keyword extraction and consolidating synonyms. Though in the current stage it aims to support analysis in bibliometric research, the framework is quite flexible to extend to various tasks in other fields. Hopefully, this work could attract more participants from both R community and academia to get involved, so as to contribute to the flourishing open science in text mining.

# Acknowledgement
This study is funded by The National Social Science Fund of China "Research on Semantic Evaluation System of Scientific Literature Driven by Big Data" (21&ZD329). This article is created using \pkg{rjtools} [@rjtools2022] in R. The source code and data for reproducing this paper can be found at: <https://github.com/hope-data-science/RJ_akc>.


